Open Issues:

1. mm_re is open in both cpu's at top level

######################################10.25###########################################
Successes 

1. completed read_miss signals, first pass on sending data from one proc to another using cache. 
setup cache read for this forwarding, exactly like normal cache read.

send data uisng cache read (cache 53-56), 
receive data and widened multiplex to select into other proc's cache (mem_h 193-204)

2. state additions/modifications to cache -> if a controller wants to write to a shared block, change state to modiff, 
it sends invalidate to the other processor and main memory -> write miss will change the other blocks state to invalidate 

3. invalidate request from other processor for a shared block -> invalidate state

4. modified state block, other proc wants to read, change state to shared in original cache
forward data to new proc and set state there to shared

5. modified state block, other proc wants to write, invalidate original (now stale) copy
other block writes new data and changes state to modified on its own new copy

Qs

1. memory signals ported from mem_hierarchy should be sent to bus or directly interfaced
to send to memory? grant? who gets to write in contention case

2. states of MSI onto valid/dirty? new bits? some combination?


######################################10.18###########################################

Current Todos:

set_dirty logic from statemachine rev

stalling, cache-access of cpu1 mandated by cpu1? or is bus and cpu0 free to access it

Issues:

1. A block can be in one of the following states in the three memories

	Cache of CPU 1		Cache of CPU 2		DMEM

1.	VALID				VALID				VALID    --> SHARED

2. 	VALID				INVALID 			INVALID  --> MODIFIED

3. 	VALID 				INVALID 			VALID    --> MODIFIED (AFTER WRITE BACK)

4.  INVALID 			INVALID 			INVALID  --> D.N.E 

5.  INVALID 			INVALID 			VALID    --> BLOCK HAS NEVER BEEN CALLED

2. 


